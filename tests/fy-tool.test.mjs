/**
 * Tests for the $fy tool (Shell to MJS translator)
 */

import { beforeAll, describe, test, expect } from 'bun:test';
import { $, register } from '../src/$.mjs';
import { writeFileSync, unlinkSync, existsSync } from 'fs';

describe('$fy tool tests', () => {
  test('should show help when no arguments provided', async () => {
    const result = await $`$fy`;
    expect(result.code).toBe(1);
    expect(result.stderr).toContain('$fy - Shell to MJS translator');
    expect(result.stderr).toContain('Usage:');
    expect(result.stderr).toContain('Examples:');
  });

  test('should convert simple command from stdin', async () => {
    const result = await $({ stdin: 'ls -la' })`$fy`;
    expect(result.code).toBe(0);
    expect(result.stdout).toContain('#!/usr/bin/env bun');
    expect(result.stdout).toContain('import { $ } from "command-stream";');
    expect(result.stdout).toContain('await $`ls -la`;');
  });

  test('should convert pipeline from stdin', async () => {
    const result = await $({ stdin: 'ls -la | grep test' })`$fy`;
    expect(result.code).toBe(0);
    expect(result.stdout).toContain('await $`ls -la | grep test`;');
  });

  test('should convert shell operators from stdin', async () => {
    const result = await $({ stdin: 'cd /tmp && pwd' })`$fy`;
    expect(result.code).toBe(0);
    expect(result.stdout).toContain('await $`cd /tmp`;');
    expect(result.stdout).toContain('await $`pwd`;');
    expect(result.stdout).toContain('// Continue only if previous succeeded');
  });

  test('should convert OR operator from stdin', async () => {
    const result = await $({ stdin: 'test -f file.txt || echo "not found"' })`$fy`;
    expect(result.code).toBe(0);
    expect(result.stdout).toContain('try {');
    expect(result.stdout).toContain('} catch (error) {');
  });

  test('should convert semicolon separator from stdin', async () => {
    const result = await $({ stdin: 'echo "first" ; echo "second"' })`$fy`;
    expect(result.code).toBe(0);
    expect(result.stdout).toContain('await $`echo "first"`;');
    expect(result.stdout).toContain('await $`echo "second"`;');
    expect(result.stdout).toContain('// Sequential execution');
  });

  test('should convert shell script file', async () => {
    const testScript = `#!/bin/bash
# Test script
echo "Hello World"
ls -la | grep test
cd /tmp && pwd
`;
    const testFile = '/tmp/test-fy-script.sh';
    writeFileSync(testFile, testScript);

    try {
      const result = await $`$fy ${testFile}`;
      expect(result.code).toBe(0);
      expect(result.stdout).toContain('#!/usr/bin/env bun');
      expect(result.stdout).toContain('// Generated by $fy tool');
      expect(result.stdout).toContain('import { $ } from "command-stream";');
      expect(result.stdout).toContain('async function main() {');
      expect(result.stdout).toContain('await $`echo "Hello World"`;');
      expect(result.stdout).toContain('await $`ls -la | grep test`;');
      expect(result.stdout).toContain('main().catch(console.error);');
    } finally {
      if (existsSync(testFile)) {
        unlinkSync(testFile);
      }
    }
  });

  test('should save converted script to output file', async () => {
    const testScript = `#!/bin/bash
echo "Test output file"
`;
    const inputFile = '/tmp/test-input.sh';
    const outputFile = '/tmp/test-output.mjs';
    
    writeFileSync(inputFile, testScript);

    try {
      const result = await $`$fy ${inputFile} ${outputFile}`;
      expect(result.code).toBe(0);
      expect(result.stdout).toContain(`Converted '${inputFile}' to '${outputFile}'`);
      expect(existsSync(outputFile)).toBe(true);
      
      // Check the output file content
      const fs = require('fs');
      const content = fs.readFileSync(outputFile, 'utf8');
      expect(content).toContain('#!/usr/bin/env bun');
      expect(content).toContain('await $`echo "Test output file"`;');
    } finally {
      [inputFile, outputFile].forEach(file => {
        if (existsSync(file)) {
          unlinkSync(file);
        }
      });
    }
  });

  test('should handle file read errors gracefully', async () => {
    const result = await $`$fy /nonexistent/file.sh`;
    expect(result.code).toBe(1);
    expect(result.stderr).toContain('Error reading file');
  });

  test('should preserve comments and structure', async () => {
    const testScript = `#!/bin/bash

# This is a comment
# Another comment

echo "Hello"

# Final comment
ls -la
`;
    const testFile = '/tmp/test-comments.sh';
    writeFileSync(testFile, testScript);

    try {
      const result = await $`$fy ${testFile}`;
      expect(result.code).toBe(0);
      expect(result.stdout).toContain('// This is a comment');
      expect(result.stdout).toContain('// Another comment');
      expect(result.stdout).toContain('// Final comment');
    } finally {
      if (existsSync(testFile)) {
        unlinkSync(testFile);
      }
    }
  });

  test('should handle shell variables', async () => {
    const result = await $({ stdin: 'VAR="test"' })`$fy`;
    expect(result.code).toBe(0);
    // Single line commands are converted directly, variables are handled in full scripts
    expect(result.stdout).toContain('await $`VAR="test"`;');
  });

  test('should handle export statements', async () => {
    const result = await $({ stdin: 'export PATH="/usr/bin"' })`$fy`;
    expect(result.code).toBe(0);
    // Single line commands are converted directly, exports are handled in full scripts  
    expect(result.stdout).toContain('await $`export PATH="/usr/bin"`;');
  });

  test('should handle shell control structures', async () => {
    const result = await $({ stdin: 'if [ -f file ]; then echo "exists"; fi' })`$fy`;
    expect(result.code).toBe(0);
    // Single line complex commands are parsed as sequences, control structures handled in full scripts
    expect(result.stdout).toContain('await $');
  });

  test('should handle complex shell script with multiple features', async () => {
    const complexScript = `#!/bin/bash
set -e

# Variables
PROJECT_DIR="/tmp/test"
export BUILD_ENV="production"

# Create and change directory
mkdir -p "$PROJECT_DIR" && cd "$PROJECT_DIR"

# Conditional execution
if [ -f package.json ]; then
  echo "Found package.json"
else
  echo "No package.json" && exit 1
fi

# Pipeline with multiple commands
cat package.json | grep name | head -1

# Sequential commands
echo "Building..."; make build; echo "Done"

# Cleanup
cd .. || exit 1
rm -rf "$PROJECT_DIR"
`;

    const testFile = '/tmp/complex-script.sh';
    writeFileSync(testFile, complexScript);

    try {
      const result = await $`$fy ${testFile}`;
      expect(result.code).toBe(0);
      
      const output = result.stdout;
      expect(output).toContain('// Generated by $fy tool');
      expect(output).toContain('async function main() {');
      expect(output).toContain('await $`set -e`;');
      expect(output).toContain('// Variable: PROJECT_DIR="/tmp/test"');
      expect(output).toContain('// Export: export BUILD_ENV="production"');
      expect(output).toContain('await $`mkdir -p "$PROJECT_DIR"`;');
      expect(output).toContain('await $`cd "$PROJECT_DIR"`;');
      expect(output).toContain('// Shell control structure: if [ -f package.json ]; then');
      expect(output).toContain('await $`cat package.json | grep name | head -1`;');
      expect(output).toContain('main().catch(console.error);');
    } finally {
      if (existsSync(testFile)) {
        unlinkSync(testFile);
      }
    }
  });
});