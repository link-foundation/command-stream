#!/usr/bin/env bun

/**
 * $fy - Shell to MJS translator
 * Converts shell scripts to JavaScript modules using command-stream
 */

import { readFileSync, writeFileSync } from 'fs';
import { parseShellCommand } from '../shell-parser.mjs';

/**
 * Convert shell command to command-stream mjs format
 */
function convertCommand(shellCommand) {
  const parsed = parseShellCommand(shellCommand.trim());
  
  if (!parsed) {
    // Fallback to sh -c for complex commands
    return `await \$\`${shellCommand.replace(/`/g, '\\`')}\`;`;
  }
  
  return convertParsedCommand(parsed);
}

/**
 * Convert parsed command structure to mjs
 */
function convertParsedCommand(parsed) {
  switch (parsed.type) {
    case 'simple':
      return convertSimpleCommand(parsed);
    case 'pipeline':
      return convertPipeline(parsed);
    case 'sequence':
      return convertSequence(parsed);
    case 'subshell':
      return `(async () => {\n  ${convertParsedCommand(parsed.command)}\n})()`;
    default:
      return `await \$\`${JSON.stringify(parsed)}\`;`;
  }
}

/**
 * Convert simple command
 */
function convertSimpleCommand(cmd) {
  const { cmd: command, args, redirects } = cmd;
  
  // Build command string
  let cmdStr = command;
  
  if (args && args.length > 0) {
    const argStr = args.map(arg => {
      if (arg.quoted) {
        return arg.quoteChar + arg.value + arg.quoteChar;
      }
      return arg.value;
    }).join(' ');
    cmdStr += ' ' + argStr;
  }
  
  // Handle redirections
  if (redirects && redirects.length > 0) {
    for (const redirect of redirects) {
      cmdStr += ` ${redirect.type} ${redirect.target}`;
    }
  }
  
  return `await \$\`${cmdStr}\`;`;
}

/**
 * Convert pipeline commands
 */
function convertPipeline(pipeline) {
  if (pipeline.commands.length === 1) {
    return convertParsedCommand(pipeline.commands[0]);
  }
  
  // Use shell-style piping for complex pipelines
  const cmdParts = pipeline.commands.map(cmd => {
    if (cmd.type === 'simple') {
      let cmdStr = cmd.cmd;
      if (cmd.args && cmd.args.length > 0) {
        const argStr = cmd.args.map(arg => {
          if (arg.quoted) {
            return arg.quoteChar + arg.value + arg.quoteChar;
          }
          return arg.value;
        }).join(' ');
        cmdStr += ' ' + argStr;
      }
      return cmdStr;
    }
    return 'unknown';
  });
  
  return `await \$\`${cmdParts.join(' | ')}\`;`;
}

/**
 * Convert sequence of commands with operators
 */
function convertSequence(sequence) {
  const { commands, operators } = sequence;
  let result = [];
  
  for (let i = 0; i < commands.length; i++) {
    const cmd = convertParsedCommand(commands[i]);
    const op = operators[i];
    
    if (op === '&&') {
      result.push(cmd);
      if (i < commands.length - 1) {
        result.push('// Continue only if previous succeeded');
      }
    } else if (op === '||') {
      result.push(`try {`);
      result.push(`  ${cmd}`);
      result.push(`} catch (error) {`);
      if (i < commands.length - 1) {
        result.push(`  // On failure, try next command`);
      }
      result.push(`}`);
    } else if (op === ';') {
      result.push(cmd);
      result.push('// Sequential execution');
    } else {
      result.push(cmd);
    }
  }
  
  return result.join('\n');
}

/**
 * Convert shell script to mjs format
 */
function convertShellScript(shellScript) {
  const lines = shellScript.split('\n');
  const mjsLines = [
    '#!/usr/bin/env bun',
    '',
    '// Generated by $fy tool - Shell to MJS translator',
    '// Source: command-stream library',
    '',
    'import { $ } from "command-stream";',
    '',
    'async function main() {',
  ];
  
  let inFunction = false;
  
  for (let line of lines) {
    line = line.trim();
    
    // Skip empty lines and comments in output, but preserve them as comments
    if (!line) {
      mjsLines.push('');
      continue;
    }
    
    if (line.startsWith('#')) {
      // Convert shell comments to JS comments
      if (line.startsWith('#!/')) {
        // Skip shebang as we already added our own
        continue;
      }
      mjsLines.push(`  // ${line.slice(1).trim()}`);
      continue;
    }
    
    // Handle shell variables and exports
    if (line.startsWith('export ') || line.includes('=')) {
      if (line.startsWith('export ')) {
        const varDef = line.slice(7).trim();
        mjsLines.push(`  // Export: ${line}`);
        mjsLines.push(`  process.env.${varDef};`);
      } else if (line.includes('=') && !line.includes(' ')) {
        // Simple variable assignment
        mjsLines.push(`  // Variable: ${line}`);
        mjsLines.push(`  // const ${line.replace('=', ' = ')};`);
      } else {
        // Command with assignment
        mjsLines.push(`  ${convertCommand(line)}`);
      }
      continue;
    }
    
    // Handle shell control structures
    if (line.startsWith('if ') || line.startsWith('elif ') || line.startsWith('else') || 
        line === 'fi' || line.startsWith('while ') || line.startsWith('for ') || 
        line.startsWith('function ') || line.includes('() {')) {
      mjsLines.push(`  // Shell control structure: ${line}`);
      mjsLines.push(`  // TODO: Convert to JavaScript equivalent`);
      continue;
    }
    
    // Regular shell commands
    try {
      const convertedCmd = convertCommand(line);
      mjsLines.push(`  ${convertedCmd}`);
    } catch (error) {
      mjsLines.push(`  // Error converting: ${line}`);
      mjsLines.push(`  // ${error.message}`);
      mjsLines.push(`  await \$\`${line.replace(/`/g, '\\`')}\`;`);
    }
  }
  
  mjsLines.push('}');
  mjsLines.push('');
  mjsLines.push('// Run the main function');
  mjsLines.push('main().catch(console.error);');
  
  return mjsLines.join('\n');
}

/**
 * $fy command implementation
 */
export async function $fy({ args, stdin }) {
  // Handle inherit case - this means no actual stdin data
  const hasStdin = stdin && stdin !== 'inherit' && stdin.trim() !== '';
  
  if (args.length === 0 && !hasStdin) {
    return {
      stderr: `$fy - Shell to MJS translator

Usage:
  $fy <input.sh>              # Convert shell script to mjs
  $fy <input.sh> <output.mjs> # Convert and save to file
  echo "ls -la" | $fy         # Convert from stdin

Examples:
  $fy deploy.sh                    # Outputs converted deploy.sh.mjs
  $fy build.sh build.mjs          # Convert build.sh to build.mjs
  echo "cd /tmp && ls" | $fy      # Convert pipeline from stdin

Features:
  - Converts shell commands to command-stream syntax
  - Handles pipelines, sequences (&&, ||, ;)
  - Preserves comments and structure
  - Provides JavaScript equivalents for shell constructs
`,
      code: 1
    };
  }
  
  try {
    let shellScript = '';
    let outputFile = '';
    
    if (hasStdin) {
      // Read from stdin
      shellScript = stdin.toString().trim();
      const converted = convertCommand(shellScript);
      return {
        stdout: `#!/usr/bin/env bun

import { $ } from "command-stream";

${converted}
`,
        code: 0
      };
    }
    
    if (args.length >= 1) {
      const inputFile = args[0];
      outputFile = args[1] || `${inputFile}.mjs`;
      
      try {
        shellScript = readFileSync(inputFile, 'utf8');
      } catch (error) {
        return {
          stderr: `Error reading file '${inputFile}': ${error.message}\n`,
          code: 1
        };
      }
      
      const convertedScript = convertShellScript(shellScript);
      
      if (args.length === 1) {
        // Output to stdout
        return {
          stdout: convertedScript,
          code: 0
        };
      } else {
        // Write to output file
        try {
          writeFileSync(outputFile, convertedScript);
          return {
            stdout: `Converted '${inputFile}' to '${outputFile}'\n`,
            code: 0
          };
        } catch (error) {
          return {
            stderr: `Error writing file '${outputFile}': ${error.message}\n`,
            code: 1
          };
        }
      }
    }
    
  } catch (error) {
    return {
      stderr: `$fy error: ${error.message}\n`,
      code: 1
    };
  }
}

// Register the virtual command if we're being imported
if (typeof globalThis.register === 'function') {
  globalThis.register('$fy', $fy);
}